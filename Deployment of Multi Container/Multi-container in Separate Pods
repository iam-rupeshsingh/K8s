Multi-container application

Each container in a separate Pod
üëâ This means Kubernetes way, not Docker Compose.

üîë First, one golden rule (very important)

1 Pod = 1 main container (recommended)
So yes üëá
Each container ‚Üí its own Pod ‚Üí its own Deployment

üß± What containers you have (example)

Let‚Äôs take your case:

Node.js app

MongoDB

So you will create:

2 Deployments

2 Services

üì¶ Architecture (visual)
[ Node.js Pod ]  --->  [ MongoDB Pod ]
       |                     |
   Node Service          Mongo Service


They talk using Service name, NOT localhost.

1Ô∏è‚É£ MongoDB Deployment (separate Pod)
mongo-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mongo-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mongo
  template:
    metadata:
      labels:
        app: mongo
    spec:
      containers:
        - name: mongo
          image: mongo:6
          ports:
            - containerPort: 27017

2Ô∏è‚É£ MongoDB Service (VERY IMPORTANT)
mongo-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: mongo
spec:
  selector:
    app: mongo
  ports:
    - port: 27017
      targetPort: 27017


üëâ Service name = mongo
Remember this.

3Ô∏è‚É£ Update server.js (this is the ‚Äúsomething‚Äù you asked)
mongoose.connect("mongodb://mongo:27017/mydb");


‚úÖ mongo = MongoDB Service name

NOT:

pod name ‚ùå

container name ‚ùå

localhost ‚ùå

4Ô∏è‚É£ Node.js Deployment (separate Pod)
node-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: node-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: node
  template:
    metadata:
      labels:
        app: node
    spec:
      containers:
        - name: node
          image: your-node-image
          ports:
            - containerPort: 3000

5Ô∏è‚É£ Node.js Service
node-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: node
spec:
  type: NodePort
  selector:
    app: node
  ports:
    - port: 3000
      targetPort: 3000
      nodePort: 30007

6Ô∏è‚É£ Apply everything
kubectl apply -f mongo-deployment.yaml
kubectl apply -f mongo-service.yaml

kubectl apply -f node-deployment.yaml
kubectl apply -f node-service.yaml

üß† How they talk (this answers your confusion about networking)

Kubernetes automatically provides:

pod-to-pod networking

DNS resolution

So inside Node Pod:

mongo  ‚Üí resolves to Mongo Service ‚Üí routes to Mongo Pod


You didn‚Äôt ‚Äúsee‚Äù networking because K8s does it for you.

‚ùå Common mistakes (don‚Äôt do this)
Mistake	Why wrong
localhost	Each pod has its own localhost
Pod name	Pod IP changes
Container name	Not used for networking
‚úÖ Final mental model (lock this)

Docker Compose ‚Üí service name

Kubernetes ‚Üí service name


----------------------------------------------------------------

Very short üëç

Node.js (app) ‚Üí ‚úÖ 2 replicas (or more) ‚Üí recommended

MongoDB ‚Üí ‚ùå 1 replica only (unless using Mongo replica set)

So:

App Deployment: replicas = 2

Mongo Deployment: replicas = 1

That‚Äôs the correct setup. ‚úÖ

server.js ‚Üí always uses service name
